//
//  File.swift
//  
//
//  Created by Benjamin Spratling on 10/15/22.
//

import Foundation


public struct DefaultCodableJSCreator {
	
	public init(_ spec:EnumCoderSpec) {
		self.spec = spec
	}
	
	public var outputFile:String {
		var finalOutput:String = "//DO NOT EDIT\n//This file is auto-generated by the SwiftCodableJSEnums Swift package plugin based on a .swiftJSEnum file\n\n"
		
		for importation in spec.imports {
			finalOutput += "import " + importation + "\n"
		}
		
		finalOutput += "extension " + spec.mainTypeName + " {\n"
		finalOutput += "\n\tprivate struct JSCodableTypeContainer : "
		
		let decodeList:String = [
			spec.createDecode ? "Decodable" : nil,
			spec.createEncode ? "Encodable" : nil,
		].compactMap({ $0 })
			.joined(separator: ", ")
		finalOutput += decodeList
		
		finalOutput += " {\n\t\tvar " + spec.typePropertyName + ":"
		+ spec.typeTypeName
		+ "\n\t}\n\n"
		
		if spec.createDecode {
			finalOutput += "\t"
			if spec.mainTypeIsPublic {
				finalOutput += "public "
			}
			finalOutput += "init(from decoder:Decoder)throws {\n\t\tlet typer = try decoder.singleValueContainer().decode(JSCodableTypeContainer.self)\n\t\tswitch typer." + spec.typePropertyName + " {\n"
			for caseSpec in spec.cases {
				finalOutput += "\t\t\tcase ." + caseSpec.name + ":\n\t\t\t\tself = ." + caseSpec.name + "(try decoder.singleValueContainer().decode(" + caseSpec.associatedValueName + ".self))\n"
			}
			finalOutput += "\t\t}\n\t}\n\n"
		}
		
		if spec.createEncode {
			
			finalOutput += "\t"
			if spec.mainTypeIsPublic {
				finalOutput += "public "
			}
			finalOutput += "func encode(to encoder: Encoder) throws {\n\t\tvar container = encoder.singleValueContainer()\n\t\t\tswitch self {\n"
			for caseSpec in spec.cases {
				finalOutput += "\t\t\tcase ." + caseSpec.name + "(let value):\n\t\t\t\ttry container.encode(value)\n"
			}
			finalOutput += "\t\t}\n"
			finalOutput += "\t\tvar subContainer = encoder.container(keyedBy: JSCodableCodingKey.self)\n\t\ttry subContainer.encode(self.type, forKey: .init(stringValue: \"" + spec.typePropertyName + "\")!)\n\t"
			finalOutput += "}\n"
		}
		
		finalOutput += "\t"
		if spec.mainTypeIsPublic, spec.typeTypeIsPublic {
			finalOutput += "public "
		}
		finalOutput += "var " + spec.typePropertyName + ":" + spec.typeTypeName + " {\n\t\tswitch self {\n"
		for caseSpec in spec.cases {
			finalOutput += "\t\t\tcase ." + caseSpec.name + "(_):\n\t\t\t\treturn." + caseSpec.name + "\n"
		}
		finalOutput += "\t\t}\n\t}"
		finalOutput += "\n}"
		
		if spec.createEncode {
			//add the custom coding key
			//we have to add it not inside the extension because the compiler thinks it's the coding key for the actual enum
			finalOutput += "\n\n\tprivate struct JSCodableCodingKey : CodingKey {\n\t\tvar stringValue: String\n\t\tinit?(stringValue: String) {\n\t\t\tself.stringValue = stringValue\n\t\t\tintValue = nil\n\t\t}\n\t\tvar intValue: Int?\n\t\tinit?(intValue: Int) {\n\t\t\tself.intValue = intValue\n\t\t\tself.stringValue = \"\\(intValue)\"\n\t\t}\n\t}\n"
		}
		
		return finalOutput
	}
	
	var spec:EnumCoderSpec
	
}


public struct EnumCoderSpec {
	public var imports:[String]
	public var mainTypeName:String
	public var mainTypeIsPublic:Bool
	public var typePropertyName:String = "type"
	public var typeTypeName:String
	public var typeTypeIsPublic:Bool
	public var cases:[CaseSpec]
	public var createDecode:Bool
	public var createEncode:Bool
	public init(imports: [String]
				,mainTypeName: String
				,mainTypeIsPublic: Bool
				,typePropertyName: String
				,typeTypeName: String
				,typeTypeIsPublic:Bool
				,cases: [CaseSpec]
				,createDecode:Bool
				,createEncode:Bool
	) {
		self.imports = imports
		self.mainTypeName = mainTypeName
		self.mainTypeIsPublic = mainTypeIsPublic
		self.typePropertyName = typePropertyName
		self.typeTypeName = typeTypeName
		self.typeTypeIsPublic = typeTypeIsPublic
		self.cases = cases
		self.createDecode = createDecode
		self.createEncode = createEncode
	}
}

public struct CaseSpec {
	public var name:String
	public var associatedValueName:String
	public init(name: String, associatedValueName: String) {
		self.name = name
		self.associatedValueName = associatedValueName
	}
}
